-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

-- | The abstract syntax of language Pawel.

module AbsPawel where

import Prelude
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String
import Data.Map (Map)

data Program = Prog [Decl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Decl
    = DExp Idt [TypeDecl] Exp
    | DLOp Integer Idt Idt
    | DROp Integer Idt Idt
    | DType Idt [Idt] [Variant]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Variant = VarType Idt [Type]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Type = TInt | TVar Idt | TFunc Type Type | TVariant Idt [Type]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Exp
    = EUnparsed [Exp]
    | EVar Idt
    | EInt Integer
    | ELet Idt [TypeDecl] Exp Exp
    | EIf Exp Exp Exp
    | ELam [Idt] Exp
    | EMatch Idt [MatchCase]
    | EApp Exp Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data MatchCase = Case Match Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Match = MVar Idt | MList [Match] | MCons Idt [Match]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data TypeDecl = TDVar Idt | TDType Idt Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Idt = Idt String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

untype :: TypeDecl -> Idt
untype (TDVar x) = x
untype (TDType x _) = x

data ExpBound
    = EBVar Idt
    | EOVar Int Idt
    | EBInt Integer
    | EBVariant Idt [ExpBound]
    | EBCons FWrapper
    | EBIf ExpBound ExpBound ExpBound
    | EBLet Idt [TypeDecl] ExpBound ExpBound
    | EBLam BEnv [Idt] ExpBound
    | EBMatch Idt [MatchCaseBound]
    | EBApp ExpBound ExpBound
    | EBOverload [ExpBound]
    | EBArith ExpBound ExpBound AriOp
    deriving (Eq, Ord, Read)
  
type BEnv = Map Idt ExpBound 

instance Show ExpBound where
    show (EBVar x) = show x
    show (EOVar n x) = show x ++ "_" ++ show n
    show (EBInt x) = show x
    show (EBVariant x []) = show x
    show (EBVariant x xs) = show x ++ "(" ++ (foldl (\a b -> a ++ ", " ++ b) (show $ head xs) (map show $ tail xs)) ++ ")"
    show (EBCons x) = show x
    show (EBIf e1 e2 e3) = "if " ++ show e1 ++ " then " ++ show e2 ++ " else " ++ show e3
    show (EBLet x tds e1 e2) = "let " ++ show x ++ " = " ++ show e1 ++ " in " ++ show e2
    show (EBLam env [] e) = "(\\_->" ++ show e ++ ")"
    show (EBLam env xs e) = "(\\" ++ (foldl (\a b -> a ++ ", " ++ b) (show $ head xs) (map show $ tail xs)) ++ " -> " ++ show e ++ ")"
    show (EBMatch x cs) = "match " ++ show x ++ " with " ++ (foldl (\a b -> a ++ " | " ++ b) (show $ head cs) (map show $ tail cs))
    show (EBApp e1 e2) = show e1 ++ " " ++ show e2
    show (EBOverload xs) = "overload " ++ (foldl (\a b -> a ++ " | " ++ b) (show $ head xs) (map show $ tail xs))
    show (EBArith e1 e2 op) = show e1 ++ " " ++ show op ++ " " ++ show e2

data FWrapper = FWCons (ExpBound -> ExpBound)
instance Show FWrapper where
    show (FWCons f) = show (f $ EBInt 0)
instance Eq FWrapper where
    (FWCons f) == (FWCons g) = f (EBInt 0) == g (EBInt 0)
instance Ord FWrapper where
    compare (FWCons f) (FWCons g) = compare (f $ EBInt 0) (g $ EBInt 0)
instance Read FWrapper where
    readsPrec _ _ = []

newtype AriOp = AriOp (Integer -> Integer -> Integer)
instance Show AriOp where
    show _ = "AriOp"
instance Eq AriOp where
    _ == _ = True
instance Ord AriOp where
    compare _ _ = EQ
instance Read AriOp where
    readsPrec _ _ = []
data MatchCaseBound = CaseBound Match ExpBound | CaseBoundOverload [MatchCaseBound]
  deriving (Eq, Ord, Show, Read)